// ------------------------------------------------------------
// Novel Data (여기만 수정하면 됨)
// ------------------------------------------------------------
const NOVEL = {
  title: "원래 고양이는 로드킬을 당하지 않는다.",
  desc: "목차에서 회차를 선택하면 바로 읽을 수 있어요.",
  episodes: [
    {
      id: "ep0",
      title: "Ep0 - 프롤로그",
      date: "작성일자 2026-01-03",
      cover: "ep0.png",
      content: `성원이 눈을 뜬 건 어둠이 물러난 새벽이었다. 머리 위로 가로등 불빛이 희미하게 남아 있었고, 벤치 아래 잔디에는 물기가 맺혀 있었다. 노란 페인트가 벗겨진 나무 결에 손바닥이 달라붙었다. 숨을 내쉴 때마다 입앞이 얇은 흰 막으로 변했다. 공원이 차가운 이유는 단순했다. 밤새 아무도 이곳을 데우지 않았기 때문이다.\n\n그는 한 번 몸을 일으키려 했다가 그만뒀다. 관절이 굳은 게 아니라, 몸이 지시를 받지 못했다. 손끝이 먼저 움직여야 하는데, 손끝까지 신호가 도달하는 데 시간이 걸렸다. 그는 벤치의 가장자리로 엉덩이를 끌어당겼다. 그 과정에서 짧은 소리가 났다. 옆길을 쓸던 형광색 조끼의 환경미화원이 고개를 들었다. 성원은 눈을 피했다. 새벽에는 시선도 체온처럼 아깝다.\n\n주머니에 손을 넣자 갈색 가죽이 거칠게 스쳤다. 그 자켓은 성인이 되던 날 선물로 받은 것이었다. 누가 줬는지는 기억나지 않았다. 이름이 떠오르지 않는 건 흔한 일이다. 주머니 안에는 사탕 껍질이 구겨져 있었고, 노래방 영수증이 접힌 채로 손가락에 걸렸다. 종이의 얇은 감촉이 어제의 시간표를 대신했다. 그는 기억을 더듬지 않았다. 기억이 있었다면, 이 벤치가 침대가 되지 않았을 것이다.\n\n반대편 주머니에서 낡은 휴대폰이 나왔다. 금속보다 더 차가운 플라스틱이 손바닥에 박혔다. 전원 버튼을 누르자 화면이 켜졌고, 숫자가 먼저 눈에 들어왔다. 05:00. 배터리 5%. 새벽의 온도는 전기도 갉아먹는다. 그는 입술을 열었다가 닫았다가 다시 열었다.\n\n“하… 오늘도 안 가면… 안 되는데.”\n\n말은 호소가 아니라 계산이었다. 출근을 하지 않으면 돈이 줄어든다. 돈이 줄면 다음 주의 선택지가 더 줄어든다. 줄어든 선택지는 다시 당장의 선택을 조급하게 만든다. 성원은 울산 성남의 작은 가게에서 시간을 팔았다. 관리자라는 명함은 권한보다 책임을 먼저 의미했다. 시간을 더 팔수록 덜 불안해졌지만, 팔 시간이 없으면 불안이 선불처럼 찾아왔다.\n\n그는 어제 만든 스케줄표를 떠올렸다. 직원들 앞에서 출근한다고 말했다. 그 말은 확신처럼 들렸지만, 표에는 색이 남아 있었다. 초록은 확정. 노랑은 후보. 빨강은 결근. 그의 이름 옆에는 노랑이 칠해져 있었다. 그건 직원들이 믿지 않은 이유가 아니라, 그 자신이 이미 믿지 않았다는 증거였다. 그는 스스로에게만 보이는 작은 보험을 들어둔 셈이었다.\n\n“미안하다… 몸이 움직여야 일을 하지…”\n\n문장을 끝내기도 전에 그는 문자를 쳤다. 받는 사람은 호영이었다. 화면의 밝기가 눈을 찔렀고, 배터리 표시는 2%로 떨어져 있었다. 손가락이 둔해져 오타가 났다. 그는 고치지 않았다. 고칠 여유는 배터리에도, 자신에게도 없었다.\n\n‘일단 출근하면 다른 지권들 1시간씩 일찍 출근하라고 말해줘’\n\n전송 버튼을 누르는 순간 화면이 꺼졌다. 검은 화면에 자신의 얼굴이 비쳤다가 사라졌다. 메시지가 갔는지는 모른다. 다만 그는 ‘갔을 것’이라고 가정했다. 가정이 없으면 다음 행동을 할 수 없다. 그는 벤치에서 몸을 떼었다. 무릎이 한 번 꺾였고, 그는 이를 악물었다. 주변이 그제야 보였다. 태화강 쪽으로 옅은 푸른 기운이 깔려 있었고, 잔디는 새벽을 그대로 머금고 있었다. 몇몇 사람만 조깅을 하고 있었다. 그들의 발걸음은 일정했고, 숨소리는 규칙적이었다. 성원은 규칙을 따라갈 체력이 없었다.\n\n“집에 가서 자야지… 추워.”\n\n그는 자켓을 더 여미고 양팔을 겨드랑이에 끼웠다. 몸의 열이 밖으로 빠져나가지 않게 막는 가장 원시적인 방법이었다. 산책로 끝으로 나가자 도로가 나타났다. 차들이 드문드문 지나갔다. 출근 준비에 바쁜 시간이라기엔 조용했고, 조용하기엔 속도가 빨랐다. 그는 택시를 기다렸다. 손을 들어 신호를 보내도 차들은 그냥 지나갔다. 새벽 다섯 시는 도시가 깨어나는 시간도, 잠드는 시간도 아니었다. 애매한 시간은 늘 서비스를 줄인다.\n\n반대편 차선에는 택시가 몇 대 보였다. 강을 넘어가는 방향이었다. 그의 집과는 반대였다. 그는 그 사실을 알면서도 그쪽을 먼저 봤다. 눈이 먼저 가는 쪽이 늘 정답은 아니지만, 때로는 선택지를 강제로 좁혀준다.\n\n“왜 이렇게 안 와… 저쪽은 많으면서.”\n\n기다리면 된다. 가장 안전한 결론은 늘 그것이다. 하지만 성원은 이미 안전을 사고로 바꿔온 사람이었다. 출근도, 술자리도, 이 벤치도. 손에 쥔 전원이 꺼진 휴대폰은 그 사실을 조용히 증명했다. 그는 반대편 인도로 가면 된다고 생각했다. 택시를 타고 나면, 방향이 반대라는 이유로 자신을 내리게 하진 못할 거라는 계산도 했다. 법은 종종 승객 편이지만, 법이 바로 도착하지 않는다는 것도 그는 알고 있었다. 무엇보다 발가락 감각이 사라지고 있었다. 몸이 내리는 결론은 늘 단순했다.\n\n횡단보도는 조금 떨어져 있었다. 그는 그쪽을 보지 않았다. 시야가 한 번 고정되면, 다른 선택지는 흐릿해진다. 차가 끊기는 타이밍을 기다렸다. 그는 달렸다. 빨라지지 않으면, 더 오래 추위를 견뎌야 한다. 그건 또 다른 종류의 벌이었다.\n\n‘끼이익’\n\n소리는 똑똑히 들렸다. 금속과 고무가 마찰할 때 나는 소리. 사람의 의지와 물리 법칙이 충돌할 때 나는 소리. 성원이 반대편 인도에 발을 디딘 직후였다. 그는 본능적으로 뒤를 돌아봤다.\n\n도로 위에 작은 검은 덩어리가 있었다. 파란 눈이 열려 있었다. 눈동자는 방향을 잃지 않았지만, 몸은 힘을 잃은 듯 도로에 눌려 있었다. 숨은 얕게 움직였다. 그 앞에 노란 택시가 멈춰 있었다. 택시의 앞범퍼 아래에 어두운 얼룩이 번지고 있었다. 새벽의 습기가 그 얼룩을 천천히 퍼뜨렸다.\n\n택시기사가 문을 열고 내렸다. 그는 주변을 먼저 살폈다. 사고를 확인하는 시선이 아니라, 목격자를 확인하는 시선이었다. 그는 혀를 차며 욕을 뱉었다. 고양이를 향한 말인지, 자신의 운을 향한 말인지 구분이 되지 않았다. 그는 발끝으로 고양이를 밀었다. 고양이 몸이 도로 가장자리로 미끄러졌다. 마치 쓰레기를 치우듯, 손을 더럽히지 않는 방식으로.\n\n“탈 거예요?”\n\n기사의 말끝이 딱딱했다. 성원은 고개를 한 번 숙였다. 택시는 아직 따뜻할 것 같았다. 그 따뜻함이 지금은 도덕보다 먼저였다. 그는 뒷좌석에 탔다. 문이 닫히자 바깥의 소리가 얇아졌다. 차 안의 공기는 이미 누군가의 체온으로 데워져 있었다.\n\n“어디요.”\n\n성원이 목적지를 말하자, 기사는 다시 인상을 찌푸렸다.\n\n“아니, 반대편 가는 차를 왜 타. 이럴 줄 알았으면 내가 안 태웠지! 원래 여기서 택시 탄다는 건 강 너머로 가겠다는 암묵적인 규칙 같은 건데, 그런 것도 몰라?”\n\n잔소리는 잔소리였지만, 기사는 손을 핸들에 붙인 채로 불법 유턴을 했다. 규칙을 말하는 입이 규칙을 지키지 않는 순간이었다. 성원은 대답하지 않았다. 대답은 책임을 나눠 갖는 일이 된다. 그는 창밖을 봤다.\n\n아까의 자리. 검은 고양이는 보이지 않았다. 도로 위에는 붉은 자국만 남아 있었다. 새벽의 바람이 그 위를 스치고 지나갔다. 자국은 곧 더 옅어질 것이다. 차들이 몇 번 더 지나가면 흔적은 흐려질 것이다. 누군가는 그 자국을 보지 못할 것이고, 보지 못한 것은 기억에 남지 않는다. 기억에 남지 않으면, 사고는 사고로 끝난다.\n\n성원은 창에 이마를 잠깐 기댔다. 택시는 앞으로 나아갔고, 뒤쪽 풍경은 멀어졌다. 붉은 자국도 시야에서 사라졌다. 그때 그는 생각했다. 방금까지 분명 거기 있었던 것이, 이렇게 아무 흔적 없이 사라질 수 있는 것인지. 그리고 사라졌다면, 그것은 어디로 갔는지.`
    },
    {
      id: "ep1",
      title: "Ep1 - 미야",
      date: "작성일자 2026-01-06",
      cover: "ep1.png",
      content: `야오는 그렇게 세상에 나왔다.\n\n미야는 처음 그 모습을 보았을 때, 물에 빠진 쥐새끼를 떠올렸다. 실제로 그런 장면을 본 적은 없었다. 다만 그렇게 생겼을 것이라 짐작했을 뿐이다. 야오는 작았고, 지나치게 여렸다. 미야의 파란 눈을 닮은 검은 털 아래로 검붉은 액체가 엉겨 붙어 있었다. 탯줄은 아직 끊어지지 않은 채 배에 매달려 있었다.\n\n미야는 조심스럽게 혀를 내밀었다. 피와 체액을 핥아내는 동안 불쾌함은 들지 않았다. 평소라면 경계했을 냄새였지만, 지금은 그렇지 않았다. 야오의 몸은 점점 마르며 형태를 갖췄다. 마지막으로 탯줄을 이로 끊었을 때, 미야는 그제야 숨을 고를 수 있었다.\n\n계절은 여름에서 가을로 넘어가고 있었다. 낙엽이 산책로를 따라 흩어져 있었다. 미야가 자리를 잡은 곳은 태화강이 내려다보이는 공원의 돌계단 아래였다. 계단을 오르내리는 인간은 많았지만, 그 바로 아래를 들여다보는 경우는 드물었다. 바쁘게 움직이는 존재는 발밑의 빈 공간에 관심을 두지 않는다. 인간이 자주 드나든다는 점은 다른 포식자에게도 부담이 되었다. 미야가 이곳을 택한 이유였다.\n\n야오가 미세하게 움직였다. 미야는 즉시 시선을 내렸다. 작은 몸이 규칙 없이 뒤척이고 있었다. 미야에게도 처음 겪는 일이었다. 본능은 하나의 결론을 내렸다. 배 속에서 유지되던 온기가 사라진 이곳은, 야오에게 차가울 것이다.\n\n“야오.”\n\n소리는 낮고 짧았다. 미야는 몸을 돌려 낙엽을 긁어모았다. 엉덩이와 앞발을 써서 돌계단 사이로 밀어 넣었다. 한 번으로는 부족했다. 같은 동작을 몇 차례 반복한 뒤에야 틈은 채워졌다. 입구에는 낙엽을 더 쌓아 바람을 막았다. 구조는 단순했고, 효과는 제한적이었다.\n\n“이제 괜찮아.”\n\n야오의 떨림은 멈추지 않았다. 오히려 더 잦아졌다. 미야는 긴장을 풀 수 없었다. 출산은 이번이 처음이 아니었다. 이미 세 마리를 낳았고, 모두 오래 머물지 못했다. 이유는 알 수 없었다. 체념에 가까운 상태로 맞이한 네 번째가 야오였다.\n\n임신 기간 동안 미야는 충분히 먹지 못했다. 출산 전날까지도 임신 사실을 인식하지 못했다. 배 속에서 자라던 네 개의 생명은 각자 다른 시점에서 한계를 맞았을 가능성이 컸다. 미야는 그 사실을 논리로 정리하지 않았다. 다만 결과만 알고 있었다.\n\n야오는 다시 몸을 움직였다. 방향은 일정했다. 미야 쪽이었다. 걸을 수 없는 몸이 선택할 수 있는 이동 방식은 하나뿐이었다. 몸을 끌며 조금씩 거리를 줄였다. 입이 미세하게 열리고 닫혔다. 공기를 찾는 것처럼, 혹은 무엇인가를 더듬는 것처럼 보였다. 결국 야오는 미야의 배에 닿았다. 계산된 행동이라기보다는, 반복된 반사에 가까운 움직임이었다.\n\n미야는 그 모습을 내려다보았다. 젖을 찾는 행동이라는 것을 알아보는 데 오래 걸리지 않았다. 그녀는 움직이지 않았다. 도와주지도, 밀어주지도 않았다. 야오가 스스로 닿기를 기다렸다. 한참이 지나서야 야오는 젖을 물었다.\n\n그 이후의 동작도 느렸다. 앞발이 번갈아 움직였고, 힘은 일정하지 않았다. 빨라지지 않았다. 미야는 시선을 떼지 못했다. 갓 태어난 새끼가 느린 것은 당연했다. 머리로는 그렇게 정리할 수 있었다. 하지만 눈앞의 움직임은 그 당연함을 넘어서 있었다. 하나하나가 지나치게 신중했고, 시간은 과하게 소모되고 있었다.\n\n젖을 다 먹는 데에는 오래 걸렸다. 미야는 시간을 세지 않았다. 다만, 한 번의 포만으로 끝날 시간이 아니라는 것만은 분명했다. 결국 야오는 젖에서 떨어졌다. 다 먹어서였는지, 미야가 먼저 몸을 옮겼기 때문인지는 알 수 없었다. 결과만 남았다. 파란 눈의 검은 몸이 눈도 뜨지 못한 채 바닥에 누워 있었다. 배는 부풀어 있었고, 호흡은 안정돼 보였다. 떨림은 잦아들었다.\n\n그럼에도 미야는 시선을 거두지 않았다. 배가 찬 상태와 살아남는 상태는 같지 않다는 것을 알고 있었기 때문이다. 이 느린 생명이 앞으로 맞닥뜨릴 시간들은 이미 충분히 계산되어 있었다. 계절은 곧 바뀔 것이고, 냄새는 줄어들 것이다. 그때 필요한 것은 충분함이 아니라 속도였다.\n\n미야가 낙엽 몇 장을 끌어와 야오의 몸 위에 덮으려던 순간, 바깥에서 소리가 났다. 규칙 없는 발걸음. 바닥을 끄는 소리. 오래된 음식물과 금속, 인간의 손이 남긴 냄새. 미야는 그 조합을 알고 있었다.\n\n“이건 또 뭐야. 입구를 다 막아놨네.”\n\n낮고 걸걸한 목소리였다. 낙엽을 건드리는 소리가 났다. 야오는 깨지 않았다. 미야는 그 점을 먼저 확인했다. 그 다음에야 입구 쪽을 보았다.\n\n레오임이 틀림없어 보였다.\n\n인간에게 길러지다 버려진 고양이. 그 사실은 그의 걸음걸이와 냄새에 남아 있었다. 사냥의 리듬이 없었고, 쓰레기통을 뒤진 흔적이 몸에 배어 있었다. 그는 늘 같은 방식으로 나타났다. 예고 없이, 그리고 너무 가까이까지.\n\n“미야! 안에 있지?”\n\n미야는 잠시 대답하지 않았다. 모른 척하면 돌아갈 수도 있었다. 하지만 그럴 경우 레오는 더 가까이 들어올 것이다. 낙엽을 헤치고, 틈을 넓히고, 결국 안쪽을 들여다볼 것이다. 그 선택지는 배제해야 했다.\n\n“왜 왔어.”\n\n소리는 낮췄다. 짜증을 숨기지도 않았다.\n\n“대답 없으면 혼자 있고 싶은 거라고 생각하고 가야지.”\n\n바깥에서 짧은 웃음소리가 났다. 낙엽 사이로 몸이 움직이는 기척이 전해졌다. 곧 헛기침 같은 소리가 뒤따랐다.\n\n“불렀는데 대답이 없으니까. 걱정돼서. 피 냄새도 나는 것 같고.”\n\n미야는 즉시 낙엽 쪽으로 시선을 돌렸다. 말보다 먼저 반응한 것은 몸이었다. 출산의 흔적은 아직 남아 있었다. 그녀는 그것을 누구에게도 보여줄 생각이 없었다. 설명할 생각도 없었다.\n\n미야는 몸을 조금 앞으로 옮겼다. 낙엽과 자신의 몸으로 안쪽을 가렸다. 그 동작에 의도가 담겼다는 것을, 그녀 자신도 알고 있었다. 지금 이곳에는 드러내지 말아야 할 것이 있었다.\n\n“피 냄새 같은 소리 하고 있네. 쓰레기통을 하도 뒤져서 코가 망가진 거 아냐?”\n\n“그런가? 뭐, 그럴 수도 있겠네. 얼마 전에 곰팡이 핀 식빵을 먹은 뒤로 좀 이상하긴 했어.”\n\n미야는 그 말에 대답하지 않았다. 그것 때문이 아니라, 원래부터 이상했다는 생각이 떠올랐지만 입 밖으로 내지 않았다. 자신이 이 고양이를 경계하고 있다는 사실이 오히려 낯설었다. 레오는 원래 이런 관심을 보일 존재가 아니었다. 고양이 회의에서 몇 번 얼굴을 본 정도였다.\n\n“그래서,” 미야가 말했다. “진짜 왜 왔어.”\n\n낙엽이 레오의 앞발에 툭툭 건드려졌다. 부수려는 의도는 없어 보였다. 단순한 확인에 가까운 동작이었다.\n\n“여기 내가 두고 간 게 있어서. 그거 좀 찾으러.”\n\n미야는 안쪽을 한 번 더 가렸다. 경계는 늦추지 않은 채였다.\n\n“내 집에? 여기 들어왔었어?”\n\n“…어.”\n\n망설임은 죄책감이라기보다는, 질문을 이해하지 못한 쪽에 가까웠다. 레오에게 침입은 개념이 아니라 이동의 결과였다.`
    }
  ]
};

// ------------------------------------------------------------
// DOM helpers
// ------------------------------------------------------------
const $ = (q) => document.querySelector(q);

$("#year").textContent = new Date().getFullYear();
$("#siteTitle").textContent = NOVEL.title;
$("#siteDesc").textContent = NOVEL.desc;

const toc = $("#tocView");
const reader = $("#readerView");
const back = $("#backToToc");
const epTitle = $("#epTitle");
const epMeta = $("#epMeta");
const epContent = $("#epContent");

const prevBtn = $("#prevBtn");
const nextBtn = $("#nextBtn");

const modeScrollBtn = $("#modeScrollBtn");
const modeBookBtn = $("#modeBookBtn");
const modeHint = $("#modeHint");
const progressHint = $("#progressHint");

const bookWrap = $("#bookWrap");
const bookStage = $("#bookStage");
const bookEpLabel = $("#bookEpLabel");
const spreadIndicator = $("#spreadIndicator");

const pageText = $("#pageText");
const pagePrevBtn = $("#pagePrevBtn");
const pageNextBtn = $("#pageNextBtn");

const pageNumberLabel = $("#pageNumberLabel");
const percentLabel = $("#percentLabel");
const progressBarFill = $("#progressBarFill");

const flipLayer = $("#flipLayer");
const sheet = $("#sheet");
const sheetFrontText = $("#sheetFrontText");
const sheetBackText = $("#sheetBackText");

const measureBox = $("#measureBox");
const measureText = $("#measureText");

// Mobile bar
const mobileMQ = window.matchMedia("(max-width:720px)");
const mPrev = $("#mPrev");
const mNext = $("#mNext");
const mMode = $("#mMode");

// ------------------------------------------------------------
// State
// ------------------------------------------------------------
let currentEpisodeIndex = -1;
let mode = localStorage.getItem("readerMode") || "scroll"; // scroll | book
let pages = [];
let pageIndex = 0;
let animLock = false;

// ------------------------------------------------------------
// LocalStorage (per-episode last page)
// ------------------------------------------------------------
const LS_KEY = "novel_reader_last_page_v1";
function loadLastPage(epId) {
  try {
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return 0;
    const obj = JSON.parse(raw);
    const v = obj?.[epId];
    return Number.isFinite(v) ? v : 0;
  } catch {
    return 0;
  }
}
function saveLastPage(epId, idx) {
  try {
    const raw = localStorage.getItem(LS_KEY);
    const obj = raw ? JSON.parse(raw) : {};
    obj[epId] = idx;
    localStorage.setItem(LS_KEY, JSON.stringify(obj));
  } catch {}
}

// ------------------------------------------------------------
// Sentence-based tokenization + natural line breaks
// ------------------------------------------------------------
function splitSentences(line) {
  const s = (line || "").trim();
  if (!s) return [];
  const matches = s.match(/[^.!?…]+[.!?…]+|[^.!?…]+$/g);
  return (matches || []).map((x) => x.trim()).filter(Boolean);
}

function tokenizeContent(content) {
  const raw = content || "";
  const paras = raw.split(/\n{2,}/);
  const tokens = [];

  paras.forEach((para, pi) => {
    const lines = para.split(/\n/);
    lines.forEach((line, li) => {
      const sents = splitSentences(line);
      sents.forEach((sent) => tokens.push({ t: "text", v: sent }));
      if (li < lines.length - 1) tokens.push({ t: "br", v: "\n" });
    });
    if (pi < paras.length - 1) tokens.push({ t: "pbr", v: "\n\n" });
  });

  while (tokens.length && (tokens[0].t === "br" || tokens[0].t === "pbr")) tokens.shift();
  return tokens;
}

function appendToken(str, tok) {
  if (tok.t === "br" || tok.t === "pbr") {
    if (!str) return "";
    if (tok.t === "pbr") {
      if (str.endsWith("\n\n")) return str;
      if (str.endsWith("\n")) return str + "\n";
    }
    return str + tok.v;
  }
  if (!str) return tok.v;
  if (str.endsWith("\n") || str.endsWith("\n\n")) return str + tok.v;
  return str + " " + tok.v;
}

// ------------------------------------------------------------
// Pagination
// ------------------------------------------------------------
function splitByChars(text, maxHeight) {
  const out = [];
  let i = 0;
  while (i < text.length) {
    let lo = i + 40;
    let hi = Math.min(text.length, i + 1400);
    let best = lo;

    while (lo <= hi) {
      const mid = Math.floor((lo + hi) / 2);
      const sub = text.slice(i, mid);
      measureText.textContent = sub;
      if (measureText.getBoundingClientRect().height <= maxHeight) {
        best = mid;
        lo = mid + 1;
      } else hi = mid - 1;
    }

    if (best <= i) best = Math.min(text.length, i + 200);
    out.push(text.slice(i, best).trim());
    i = best;
  }
  return out.filter(Boolean);
}

function buildPages() {
  const ep = NOVEL.episodes[currentEpisodeIndex];
  if (!ep) return;

  pages = [];

  const stageRect = bookStage.getBoundingClientRect();
  const styles = getComputedStyle(document.documentElement);
  const padX = parseFloat(styles.getPropertyValue("--pagePadX")) || 18;
  const padY = parseFloat(styles.getPropertyValue("--pagePadY")) || 18;

  const shellW = Math.max(260, stageRect.width - 28);
  const shellH = Math.max(220, stageRect.height - 84);
  const contentW = Math.max(220, shellW - padX * 2);
  const contentH = Math.max(180, shellH - padY * 2);

  measureBox.style.width = contentW + "px";
  measureText.style.width = contentW + "px";

  const tokens = tokenizeContent(ep.content);
  let buf = "";

  for (const tok of tokens) {
    const candidate = appendToken(buf, tok);
    measureText.textContent = candidate;

    if (measureText.getBoundingClientRect().height <= contentH) {
      buf = candidate;
      continue;
    }

    if (buf.trim()) {
      pages.push(buf.trimEnd());
      buf = "";
    }

    if (tok.t === "br" || tok.t === "pbr") continue;

    const single = appendToken("", tok);
    measureText.textContent = single;

    if (measureText.getBoundingClientRect().height <= contentH) {
      buf = single;
    } else {
      const chunks = splitByChars(single, contentH);
      pages.push(...chunks.slice(0, -1));
      buf = chunks[chunks.length - 1] || "";
    }
  }

  if (buf.trim()) pages.push(buf.trimEnd());
}

// ------------------------------------------------------------
// Render + progress
// ------------------------------------------------------------
function clamp(n, a, b) {
  return Math.max(a, Math.min(b, n));
}

function updateProgressUI() {
  const total = Math.max(1, pages.length);
  const current = clamp(pageIndex, 0, total - 1);
  const percent = Math.round(((current + 1) / total) * 100);

  progressHint.textContent = `페이지: ${current + 1}/${total} · ${percent}%`;

  pageNumberLabel.textContent = `p. ${current + 1} / ${total}`;
  percentLabel.textContent = `${percent}%`;
  progressBarFill.style.width = `${percent}%`;

  const ep = NOVEL.episodes[currentEpisodeIndex];
  if (ep) saveLastPage(ep.id, current);

  pagePrevBtn.style.visibility = current > 0 ? "visible" : "hidden";
  pageNextBtn.style.visibility = current < total - 1 ? "visible" : "hidden";
}

function renderPage(idx) {
  if (!pages.length) {
    pageText.textContent = "";
    spreadIndicator.textContent = `0 / 0`;
    progressHint.textContent = `페이지: 0/0 · 0%`;
    pageNumberLabel.textContent = `p. 0 / 0`;
    percentLabel.textContent = `0%`;
    progressBarFill.style.width = `0%`;
    return;
  }
  pageIndex = clamp(idx, 0, pages.length - 1);
  pageText.textContent = pages[pageIndex] ?? "";
  spreadIndicator.textContent = `${pageIndex + 1} / ${pages.length}`;
  updateProgressUI();
}

// ------------------------------------------------------------
// Modes + Mobile auto switching
// ------------------------------------------------------------
function isMobile() {
  return mobileMQ.matches;
}

function setMode(nextMode) {
  mode = nextMode;
  localStorage.setItem("readerMode", mode);

  modeScrollBtn.classList.toggle("active", mode === "scroll");
  modeBookBtn.classList.toggle("active", mode === "book");

  if (mode === "scroll") {
    modeHint.textContent = "모드: 스크롤";
    epContent.style.display = "block";
    bookWrap.style.display = "none";
    progressHint.textContent = "-";
    mMode.textContent = "스크롤";
  } else {
    modeHint.textContent = "모드: 책(단면)";
    epContent.style.display = "none";
    bookWrap.style.display = "block";
    mMode.textContent = "책";

    const ep = NOVEL.episodes[currentEpisodeIndex];
    buildPages();
    const last = ep ? loadLastPage(ep.id) : 0;
    renderPage(clamp(last, 0, Math.max(0, pages.length - 1)));
    bookEpLabel.textContent = ep?.title ?? "";
  }
}

function autoModeByDevice() {
  if (currentEpisodeIndex < 0) return;
  if (isMobile()) setMode("scroll");
  else setMode(localStorage.getItem("readerMode") || "book");
}

// ------------------------------------------------------------
// Flip animation
// ------------------------------------------------------------
function flipTo(nextIdx) {
  if (animLock) return;
  if (nextIdx === pageIndex) return;
  if (nextIdx < 0 || nextIdx >= pages.length) return;

  const dir = nextIdx > pageIndex ? "next" : "prev";
  animLock = true;

  flipLayer.style.display = "block";
  flipLayer.classList.add("active");
  flipLayer.classList.remove("flipNext", "flipPrev");

  if (dir === "next") {
    sheet.style.transformOrigin = "left center";
    sheetFrontText.textContent = pages[pageIndex] ?? "";
    sheetBackText.textContent = pages[nextIdx] ?? "";
    flipLayer.classList.add("flipNext");
  } else {
    sheet.style.transformOrigin = "right center";
    sheetFrontText.textContent = pages[pageIndex] ?? "";
    sheetBackText.textContent = pages[nextIdx] ?? "";
    flipLayer.classList.add("flipPrev");
  }

  const dur = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--flipDur")) || 620;
  const midMs = Math.max(240, Math.floor(dur / 2));
  setTimeout(() => renderPage(nextIdx), midMs);

  const onEnd = () => {
    sheet.removeEventListener("animationend", onEnd);
    flipLayer.classList.remove("flipNext", "flipPrev", "active");
    flipLayer.style.display = "none";
    animLock = false;
  };
  sheet.addEventListener("animationend", onEnd);
}

// ------------------------------------------------------------
// TOC + episode navigation (✅ cover 포함 카드형)
// ------------------------------------------------------------
function renderToc() {
  toc.innerHTML = `
    <div class="tocHead">
      <div class="tocTitle">목차</div>
      <div class="tocSub">${NOVEL.episodes.length} Episodes</div>
    </div>

    <div class="tocGrid">
      ${NOVEL.episodes.map(ep => `
        <a class="tocCard" href="#${ep.id}">
          <div class="tocThumb" style="background-image:url('${ep.cover || ""}')">
            ${ep.cover ? "" : `<div class="tocThumbFallback">NO IMAGE</div>`}
          </div>
          <div class="tocInfo">
            <div class="tocEpTitle">${ep.title}</div>
            <div class="tocMeta">${ep.date ?? ""}</div>
          </div>
        </a>
      `).join("")}
    </div>
  `;
}

function showEpisodeByHash() {
  const id = location.hash.replace("#", "");
  const idx = NOVEL.episodes.findIndex((e) => e.id === id);

  if (idx === -1) {
    reader.style.display = "none";
    toc.style.display = "block";
    return;
  }

  currentEpisodeIndex = idx;
  const ep = NOVEL.episodes[idx];

  toc.style.display = "none";
  reader.style.display = "block";

  epTitle.textContent = ep.title;
  epMeta.textContent = ep.date ? `업데이트: ${ep.date}` : "";
  epContent.textContent = ep.content;

  prevBtn.style.visibility = idx > 0 ? "visible" : "hidden";
  nextBtn.style.visibility = idx < NOVEL.episodes.length - 1 ? "visible" : "hidden";

  prevBtn.onclick = (e) => {
    e.preventDefault();
    location.hash = NOVEL.episodes[idx - 1].id;
  };
  nextBtn.onclick = (e) => {
    e.preventDefault();
    location.hash = NOVEL.episodes[idx + 1].id;
  };

  autoModeByDevice();
}

// ------------------------------------------------------------
// Mobile “Focus mode” : 책/스크롤 터치 시 컨트롤 숨김/표시
// - 모바일에서 하단바가 집중력 흐리는 문제 해결
// ------------------------------------------------------------
let focusTimer = null;
function enterFocus() {
  if (!isMobile()) return;
  document.body.classList.add("readingFocus");
}
function exitFocus() {
  document.body.classList.remove("readingFocus");
}
function pulseFocus() {
  if (!isMobile()) return;
  exitFocus();
  clearTimeout(focusTimer);
  focusTimer = setTimeout(() => enterFocus(), 1400);
}

// 본문 터치 시 컨트롤 잠깐 보여줬다가 다시 숨김
epContent.addEventListener("touchstart", pulseFocus, { passive:true });
bookStage.addEventListener("touchstart", pulseFocus, { passive:true });

// ------------------------------------------------------------
// UI wiring
// ------------------------------------------------------------
back.onclick = (e) => {
  e.preventDefault();
  location.hash = "";
};

modeScrollBtn.onclick = (e) => {
  e.preventDefault();
  setMode("scroll");
};
modeBookBtn.onclick = (e) => {
  e.preventDefault();
  setMode("book");
};

pagePrevBtn.onclick = (e) => {
  e.preventDefault();
  flipTo(pageIndex - 1);
};
pageNextBtn.onclick = (e) => {
  e.preventDefault();
  flipTo(pageIndex + 1);
};

mPrev.onclick = (e) => {
  e.preventDefault();
  if (mode === "book") flipTo(pageIndex - 1);
  else window.scrollBy({ top: -window.innerHeight * 0.75, behavior: "smooth" });
};
mNext.onclick = (e) => {
  e.preventDefault();
  if (mode === "book") flipTo(pageIndex + 1);
  else window.scrollBy({ top: window.innerHeight * 0.75, behavior: "smooth" });
};
mMode.onclick = (e) => {
  e.preventDefault();
  const next = mode === "scroll" ? "book" : "scroll";
  setMode(next);
};

// keyboard (desktop)
window.addEventListener("keydown", (e) => {
  if (mode !== "book") return;
  if (reader.style.display === "none") return;
  if (e.key === "ArrowRight") flipTo(pageIndex + 1);
  if (e.key === "ArrowLeft") flipTo(pageIndex - 1);
});

// swipe
let touchX = null;
bookStage.addEventListener(
  "touchstart",
  (e) => {
    if (mode !== "book") return;
    touchX = e.touches[0].clientX;
  },
  { passive: true }
);

bookStage.addEventListener(
  "touchend",
  (e) => {
    if (mode !== "book") return;
    if (touchX === null) return;
    const endX = e.changedTouches[0].clientX;
    const dx = endX - touchX;
    touchX = null;

    const threshold = 50;
    if (dx < -threshold) flipTo(pageIndex + 1);
    else if (dx > threshold) flipTo(pageIndex - 1);
  },
  { passive: true }
);

// resize reflow
let resizeTimer = null;
window.addEventListener("resize", () => {
  if (mode !== "book") return;
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(() => {
    const keep = pageIndex;
    buildPages();
    renderPage(clamp(keep, 0, Math.max(0, pages.length - 1)));
  }, 140);
});

// device change
mobileMQ.addEventListener?.("change", () => autoModeByDevice());

// ------------------------------------------------------------
// Init
// ------------------------------------------------------------
renderToc();
window.addEventListener("hashchange", showEpisodeByHash);
showEpisodeByHash();
enterFocus();